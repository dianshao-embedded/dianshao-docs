[{"id":0,"href":"/dianshao-docs/roadmap/yocto/","title":"Yocto 介绍","parent":"教程","content":""},{"id":1,"href":"/dianshao-docs/yocto/yocto/","title":"Yocto 介绍","parent":"Yocto 教程","content":""},{"id":2,"href":"/dianshao-docs/lora-gateway/project/","title":"创建项目","parent":"实例一","content":"    1. 创建项目 2. 增加元数据层 3. 上传至远端仓库      1. 创建项目      项目名为 lora-gateway-imx6ull yocto 版本选择 hardknott 点击创建，等待项目初始化完成，如果网络不好，时间会较长  2. 增加元数据层     计划使用 imx6ull 芯片，因此需要额外添加 freescale 和 freescale-distro 两个元数据层\n meta-freescale: 名称 meta-freescale, url https://github.com/Freescale/meta-freescale.git meta-freescale-distro: 名称 meta-freescale-distro, url https://github.com/Freescale/meta-freescale-distro.git  等待元数据层添加完成\n3. 上传至远端仓库     本项目将作为例程上传至 dianshao-embedded/lora-gateway-imx6ull 仓库中\n"},{"id":3,"href":"/dianshao-docs/usermanual/overview/","title":"概述","parent":"用户手册","content":"    1. 项目背景 2. 项目范围 3. 开发流程      1. 项目背景     颠勺平台是一个嵌入式 Yocto Linux 终端项目构建管理工具，具有以下特征\n 提供 BBFILE 自动生成功能降低开发 Yocto 项目的难度，对初学者友好 提供标准化的嵌入式 Linux 项目开发管理流程，提高嵌入式终端项目的可维护性 提供 Yocto 项目模板导入导出功能，用标准化的项目模板加速开发 项目运行于 Docker 容器之上，可跨平台部署（Linux、Windows），部署简便  开发该项目的初衷是为了帮助自己更方便的开发 Yocto 项目，同时方便嵌入式开发团队协同开发。\n2. 项目范围     由于 Yocto-Linux 开发过程复杂，不容易归纳。因此颠勺项目只帮助用户构建文件系统，包括文件系统构建以及其中包含的所有软件，而不涉及内核、驱动及u-boot\n 应用软件包自动构建（非内核、驱动、u-boot 软件） 文件系统自动构建 镜像及升级包自动构建  3. 开发流程     使用颠勺开发 Yocto 项目主要分为四步，详情参考后续章节\n  创建 Yocto 项目，并根据需求增加相应的元数据层，默认创建的 Yocto 项目中包括 bitbake, meta-yocto, meta-openembedded, meta-rauc\n  在新建的 Yocto 项目中开发 u-boot, 内核，驱动，rauc bbappend, machine conf 等底层软件包。开发方式完全按照 Yocto 项目说明即可，颠勺不提供该部分相关功能。\n  在颠勺 MyPackage 中添加用户应用层软件包\n  在颠勺 MyImage 中添加镜像配置，由于制作文件系统、镜像以及升级包\n  "},{"id":4,"href":"/dianshao-docs/usermanual/","title":"用户手册","parent":"欢迎使用颠勺","content":""},{"id":5,"href":"/dianshao-docs/quickstart/introduction/","title":"简介","parent":"入门","content":"    1. 项目特征 2. 依赖项目 3. 系统架构      1. 项目特征       一个嵌入式 Yocto Linux 终端项目构建管理工具\n  提供 BBFILE 自动生成功能降低开发 Yocto 项目的难度，对初学者友好\n  提供标准化的嵌入式 Linux 项目开发管理流程，提高嵌入式终端项目的可维护性\n  提供 Yocto 项目模板导入导出功能，用标准化的项目模板加速开发\n  项目运行于 Docker 容器之上，可跨平台部署（Linux、Windows），部署简便\n  2. 依赖项目     颠勺主要是基于 Django 开发， 它通过由 Celery + Redis 支持的异步队列发送 bitbake 命令进行编译等操作，另外它使用 Postgresql 作为数据库\n为了快速可靠的安装部署，颠勺和相关依赖均运行于 Docker 容器之中\n Bitbake Yocto Django Docker Postgresql Celery Redis Skeleton JQuery  3. 系统架构     颠勺主要由 dianshao-web 和 dianshao-yocto 两部分组成。前者负责提供 UI 交互界面，项目管理，包管理，元数据层管理等工作，后者负责项目创建，BBFILE 创建，Bitbake 命令运行等底层工作。正常工作时，dianshao-web 下发任务至 dianshao-yocto，并实时读取任务状态。另外，Bitbake 任务进程相关状态值由 dianshao-yocto 通过 UDP 报文主动上报给 dianshao-web\n"},{"id":6,"href":"/dianshao-docs/lora-gateway/machine/","title":"底层开发","parent":"实例一","content":"    1. 硬件组成 2. u-boot  2.1 设备树开发 2.2 board 开发 2.3 config 2.4 bbfile   3. kernel  3.1 设备树 3.2 config 文件 3.3 Makefile Patch 3.4 linux bbappend   4. machine conf 5. distro conf      1. 硬件组成     对于一个基础的 LoRa 网关，主要有以下外设\n LoRa 模块: semtech sx1301 基带芯片 4G 模块: 移远 EC20 PHY: KSZ8081 使用 SD 卡作为存储  2. u-boot     2.1 设备树开发     设备树开发可参考官方开发板设备树文件，其实也无需过多改动，因为 u-boot 的用途只是加载内核及内核设备树，所以只需确保 SD 可用就可以了\n本例程中新建 imx6ull-lgw-uboot.dts, 其中 SD 相关设置如下\n\u0026amp;usdhc1 { pinctrl-names = \u0026#34;default\u0026#34;, \u0026#34;state_100mhz\u0026#34;, \u0026#34;state_200mhz\u0026#34;; pinctrl-0 = \u0026lt;\u0026amp;pinctrl_usdhc1\u0026gt;; pinctrl-1 = \u0026lt;\u0026amp;pinctrl_usdhc1_100mhz\u0026gt;; pinctrl-2 = \u0026lt;\u0026amp;pinctrl_usdhc1_200mhz\u0026gt;; keep-power-in-suspend; broken-cd; vmmc-supply = \u0026lt;\u0026amp;reg_sd1_vmmc\u0026gt;; status = \u0026#34;okay\u0026#34;; }; 2.2 board 开发     通常来说，每种终端产品都要开发 board 相关的初始化代码及头文件。但是正如上述所说，u-boot 用途只是加载内核，所以可以使用官方开发板的 board 代码进行少量修改。\n本例程中使用 imx6ull 芯片，所以我使用 imx6ullevk 开发板的 board 代码，并对头文件进行修改以正确加载内核及设备树\n2.3 config     config 同样可以参照 imx6ullevk 的默认配置，需确认启动方式，以及设备树选择\nCONFIG_DEFAULT_DEVICE_TREE=\u0026#34;imx6ull-gw1000-uboot\u0026#34; 同时要制作设备树文件夹下 makefile 文件补丁，添加 2.1 中新建的设备树\n--- ./arch/arm/dts/Makefile +++ ./arch/arm/dts/Makefile @@ -724,7 +724,8 @@ imx6ull-somlabs-visionsom.dtb \\ imx6ulz-14x14-evk.dtb \\ imx6ulz-14x14-evk-emmc.dtb \\ -\timx6ulz-14x14-evk-gpmi-weim.dtb +\timx6ulz-14x14-evk-gpmi-weim.dtb \\ +\timx6ull-gw1000-uboot.dtb dtb-$(CONFIG_ARCH_MX6) += \\ imx6-apalis.dtb \\ 2.4 bbfile     需要通过 u-boot.bbappend 将上述改动添加进编译过程\n# u-boot-imx-% # Auto Generate by Dianshao FILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/files:\u0026#34; DESCRIPTION = \u0026#34;u-boot-imx bbappend\u0026#34; LICENSE = \u0026#34;\u0026#34; DEPENDS = \u0026#34;vim-native bison-native\u0026#34; SRC_URI_append = \u0026#34;\\ file://mx6ullevk.h.patch \\ file://Makefile.patch \\ file://mx6ull_gw1000_defconfig \\ file://imx6ull-gw1000-uboot.dts \\ \u0026#34; do_configure_prepend () { cp ${WORKDIR}/mx6ull_gw1000_defconfig ${S}/configs cp ${WORKDIR}/imx6ull-gw1000-uboot.dts ${S}/arch/arm/dts } 3. kernel     3.1 设备树     针对上述外设，设备树需增加以下部分内容\n SD 卡  \u0026amp;usdhc1 { pinctrl-names = \u0026#34;default\u0026#34;, \u0026#34;state_100mhz\u0026#34;, \u0026#34;state_200mhz\u0026#34;; pinctrl-0 = \u0026lt;\u0026amp;pinctrl_usdhc1\u0026gt;; pinctrl-1 = \u0026lt;\u0026amp;pinctrl_usdhc1_100mhz\u0026gt;; pinctrl-2 = \u0026lt;\u0026amp;pinctrl_usdhc1_200mhz\u0026gt;; keep-power-in-suspend; broken-cd; vmmc-supply = \u0026lt;\u0026amp;reg_sd1_vmmc\u0026gt;; status = \u0026#34;okay\u0026#34;; };  spi - lora 芯片  \u0026amp;ecspi1 { pinctrl-names = \u0026#34;default\u0026#34;; pinctrl-0 = \u0026lt;\u0026amp;pinctrl_ecspi1_1 \u0026amp;pinctrl_ecspi1_cs_1\u0026gt;; fsl,spi-num-chipselects = \u0026lt;1\u0026gt;; //cs-gpios = \u0026lt;\u0026amp;gpio4 26 0\u0026gt;; status = \u0026#34;okay\u0026#34;; spidev0: spidev@0 { compatible = \u0026#34;spidev\u0026#34;; spi-max-frequency = \u0026lt;8000000\u0026gt;; reg = \u0026lt;0\u0026gt;; };\t};  usb - ec20  \u0026amp;usbotg2 { dr_mode = \u0026#34;host\u0026#34;; disable-over-current; status = \u0026#34;okay\u0026#34;; };  fec - phy  \u0026amp;fec1 { pinctrl-names = \u0026#34;default\u0026#34;; pinctrl-0 = \u0026lt;\u0026amp;pinctrl_enet1\u0026gt;; phy-mode = \u0026#34;rmii\u0026#34;; phy-handle = \u0026lt;\u0026amp;ethphy0\u0026gt;; phy-reset-gpios = \u0026lt;\u0026amp;gpio5 8 GPIO_ACTIVE_LOW\u0026gt;; phy-reset-duration = \u0026lt;10\u0026gt;; local-mac-address = [00 06 34 01 01 01]; status = \u0026#34;okay\u0026#34;; mdio { #address-cells = \u0026lt;1\u0026gt;; #size-cells = \u0026lt;0\u0026gt;; ethphy0: ethernet-phy@2 { reg = \u0026lt;2\u0026gt;; micrel,led-mode = \u0026lt;1\u0026gt;; clocks = \u0026lt;\u0026amp;clks IMX6UL_CLK_ENET_REF\u0026gt;; clock-names = \u0026#34;rmii-ref\u0026#34;; }; }; }; 3.2 config 文件     在 freescale 官方配置文件基础上，还需添加以下几点\n ppp 支持  CONFIG_PPP=y CONFIG_PPP_BSDCOMP=y CONFIG_PPP_DEFLATE=y CONFIG_PPP_FILTER=y CONFIG_PPP_MPPE=y CONFIG_PPP_MULTILINK=y CONFIG_PPP_ASYNC=y CONFIG_PPP_SYNC_TTY=y CONFIG_SLHC=y  usb wwan 支持  CONFIG_USB_ACM=y CONFIG_USB_SERIAL=y CONFIG_USB_SERIAL_WWAN=y CONFIG_USB_SERIAL_OPTION=y  tmpfs 支持  CONFIG_TMPFS=y CONFIG_TMPFS_POSIX_ACL=y CONFIG_TMPFS_XATTR=y CONFIG_MEMFD_CREATE=y 3.3 Makefile Patch     修改 dts 目录下 Makefile 以增加新增设备树\n--- ./arch/arm/boot/dts/Makefile +++ ./arch/arm/boot/dts/Makefile @@ -692,6 +692,7 @@ imx6ull-phytec-segin-ff-rdk-nand.dtb \\ imx6ull-phytec-segin-ff-rdk-emmc.dtb \\ imx6ull-phytec-segin-lc-rdk-nand.dtb \\ +\timx6ull-gw1000.dtb \\ imx6ulz-14x14-evk.dtb \\ imx6ulz-14x14-evk-btwifi.dtb \\ imx6ulz-14x14-evk-gpmi-weim.dtb \\ 3.4 linux bbappend     增加 bbappend 将上述改动增加到编译过程\n# linux-imx-5.10 # Auto Generate by Dianshao FILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/files:\u0026#34; DESCRIPTION = \u0026#34;linux-imx bbappend for lorawan gateway\u0026#34; SRC_URI_append = \u0026#34;\\ file://Makefile.patch \\ file://gw1000.cfg \\ file://imx6ull-gw1000.dts \\ \u0026#34; do_configure_append () { cat ../*cfg \u0026gt;\u0026gt; ${B}/.config } do_compile_prepend () { cp ${WORKDIR}/imx6ull-gw1000.dts \\ ${S}/arch/${ARCH}/boot/dts } 4. machine conf     我们在官方提供的 imx6ullevk.conf 的基础上进行修改，主要是有如下部分\n uboot 配置文件和启动方式  UBOOT_CONFIG = \u0026#34;sd\u0026#34; UBOOT_CONFIG[sd] = \u0026#34;mx6ull_gw1000_defconfig,sdcard\u0026#34;  uboot 编译产物名称  UBOOT_SUFFIX = \u0026#34;imx\u0026#34; UBOOT_MAKE_TARGET = \u0026#34;u-boot.imx\u0026#34;  fsl 内核要求宏  ACCEPT_FSL_EULA = \u0026#34;1\u0026#34;  内核设备树  KERNEL_DEVICETREE = \u0026#34;imx6ull-gw1000.dtb\u0026#34; 5. distro conf     在官方提供的 fsl-base.inc 基础上进行修改\n 名称及版本号  DISTRO = \u0026#34;dianshao\u0026#34; DISTRO_NAME = \u0026#34;dianshao\u0026#34; DISTRO_VERSION = \u0026#34;1.0.0\u0026#34;  选择 systemd 为启动方式  DISTRO_FEATURES_append = \u0026#34; systemd\u0026#34; VIRTUAL-RUNTIME_init_manager = \u0026#34;systemd\u0026#34; "},{"id":7,"href":"/dianshao-docs/quickstart/quickstart/","title":"快速开始","parent":"入门","content":"    1. 说明 2. 安装  2.1 资源要求 2.2 安装准备 2.3 安装   3. 创建项目 4. 增加元数据层 5. 测试 Bitbake 命令 6. 增加软件包 7. 制作并编译镜像文件 8. 项目上传      1. 说明     本文将从零开始，让您快速的部署颠勺并构建第一个 Yocto 项目。\n本文主要目的是让您快速体验颠勺，希望在短时间内，可以说服您这个项目对嵌入式 Linux 项目开发是非常有用，可以提供生产力的。\n总的来说，颠勺是 Bitbake 的拓展，目的是帮助开发者更方便的开发 Yocto 项目\n如果你对 Yocto 很熟悉，那你会很快掌握颠勺。如果你是一个初学者，颠勺将帮助你快速理解和学会开发 Yocto 项目。但是建议你最好有一定的嵌入式 Linux 开发经验。\n详细的使用说明请参考颠勺用户手册，里面会更加详细的介绍颠勺所有的功能以及您最好掌握的相关知识说明。\n2. 安装     2.1 资源要求     由于需要编译 Yocto 项目，所以对资源要求较高，具体要求如下\n 内存最小 4GB，推荐使用 8GB 及以上 硬盘剩余空间大于 80GB  同时，为了提高编译效率，需要较多的 CPU 核，根据我个人的使用经验，10核以下机器编译体验较差。因此不建议长期使用个人电脑运行颠勺，编译效率过低往往会打消您的热情，影响您的工作效率。推荐将颠勺运行于服务器或者工作站之上，一台普通的16核32G的服务器即可满足要求。\n除此之外，非常重要的一点是请确保您的网络可以通畅连接到各个源码仓库。Yocto 项目采用完全从源码编译的方式构建项目，因此第一次编译时需要拉取项目包含的软件源码包。如果您的机器无法很好的访问这些源码仓库，你会遇到多次失败，或者等待一周甚至更长时间也无法完成编译。\n工欲善其事必先利其器，建议您将宿主机的资源和网络准备好后再开始使用颠勺\n2.2 安装准备     目前，颠勺已经在 Windows (Win10 \u0026amp; Win11) 和 Linux (Ubuntu, Fedora, CentOS 8) 环境下完成测试。你可以选择你习惯的操作系统环境作为 Docker 主机， 请根据如下官方文档安装 Docker \u0026amp; Docker-Compose\ndocker 安装说明docker-compose 安装说明2.3 安装       下载项目\n在 Linux 环境中使用\n$ git clone https://github.com/croakexciting/dianshao.git \u0026amp;\u0026amp; cd ./dianshao 注意：由于 Bitbake 无法被 root 用户使用，因此请确保项目文件夹权限为 1000：1000\n在 Windows 环境中使用\n$ git clone https://github.com/croakexciting/dianshao.git -c core.autocrlf=false $ cd ./dianshao   设置你的 Yocto Project 项目存放路径\n$ export DIANSHAO_YOCTO_PROJECT_PATH=\u0026#34;your yocto project path\u0026#34; 注意：如果在 Linux 中使用，请确保项目文件夹权限为 1000：1000\n$ sudo chown -R 1000:1000 $DIANSHAO_YOCTO_PROJECT_PATH 注意：如果在 Windows 中使用，请打开该文件夹大小写敏感选项\n$ fsutil.exe file setCaseSensitiveInfo $DIANSHAO_YOCTO_PROJECT_PATH enable   Docker 镜像编译\n$ sudo docker-compose build 注意：如果使用国内网络编译速度过慢，可使用如下命令使用国内镜像源\n$ sudo docker-compose -f docker-compose-with-mirror.yml build   Docker 容器启动\n$ sudo docker-compose up 注意：如果使上一步使用国内镜像源，请使用下面命令\n$ sudo docker-compose -f docker-compose-with-mirror.yml up   3. 创建项目     注意：创建项目时需要拉取 Bitbake 等项目仓库，请确保您的网络畅通\n输入项目名称并选择 Yocto 版本号，然后点击创建\n等待项目初始化完成，初始化时间根据你的网络情况，可能会很长，请耐心等待\n如果初始化成功，页面如下所示\n4. 增加元数据层     初始化完成的 Yocto 项目中只包含核心层，如果你需要增加其他元数据层，请点击 Add Therd-Party MetaLayer 按钮\n输入元数据层名称并且选择导入方式，remote 方式意味这你想导入的层目前不在该 Yocto 项目主目录中，local 意思则相反。如果你选择 remote, 你需要输入 Url.\nsub 意义为：如果你想导入的层是某个 Git 仓库的子目录， 例如 meta-openembedded/meta-oe/，那你需要在 sub 中填写 meta-oe\n等待进程结束，你会发现新添加的元数据层已经在列表中了\n5. 测试 Bitbake 命令     你可以在 bitbake command 界面中操作 bitbake，可以在该界面中感受颠勺如何操作 bitbake.\n注意：Bitbake 需要从零构建，对网络环境和计算资源要求很高，如果你使用普通个人电脑和国内网络，第一次编译的时间可能很长，请耐心\n6. 增加软件包     注意：颠勺自动创建的 Yocto 项目中，默认使用 qemux86-64 作为待开发机器，并默认使用 Systemd 作为启动引导。您可按照 Yocto 开发说明对 machine 和 distro 进行修改，颠勺暂时不提供该部分支持。\n进入刚刚创建的项目后，点击 DEVELOP MY META 或者点击顶栏中的 MyPackages 进入 MyPackage 界面\n点击 NEW PACKAGES 创建新的 Yocto Package. 目前颠勺提供对 C/C++ 项目以及 Golang 项目的支持。当然这并不是说您无法增加其他语言的软件包，只是您需要非常了解如何制作这些语言软件包的 BBFILE 文件。\n在本例程中，我们随机选择了一个 C 语言项目，makefile-example. 由于为 C 语言项目，因此创建时参数应按如下填写。\n完成创建后，点击该软件包右边的 DETAIL 按钮进入详情，在详情中填写该软件包仓库地址、源码路径等参数，这些均为创建 Yocto 包的必要宏定义，您可以去 Yocto 使用说明中查看其具体含义。上述项目填写如下\n填写完成后，点击 Update Package 按钮，更新包详情。然后点击 ADD ORIGINAL TASK 添加编译任务，该项目编译任务为 oe_runmake，任务类型选择为 COMPILE，子类型选 NONE，这些参数意义请见用户手册中的 MyPackage 部分，如下图所示。\n然后再点击 ADD INSTALL TASK，我们将编译出来的可执行文件放置到终端固件文件系统中的 /usr/bin 文件夹下，如下图所示。\n完成上述操作后，点击 GENERATE BB/BBAPPEND FILE 即可自动生成 Yocto 包。您可以点击 Bitbake It 按钮测试编译该包。\n7. 制作并编译镜像文件     终端项目的最终目的是完成 u-boot，内核，文件系统的编译和制作，并将其打包为镜像文件。为了方便项目的裁剪，同一个项目里可以有多个镜像，每个镜像中可以有不同的文件系统，但是 u-boot 和内核只允许存在一个。\nyocto 已经提供了两个基础文件系统，我们只需在其基础上增加自己的软件包即可，创建镜像完成后，我们加入刚才增加的makefile-example 包，并点击 Make Image 按钮制作镜像文件。如下图所示\n完成镜像制作后，我们在该镜像界面点击 Bitbake Image 按钮编译该镜像。第一次编译的时间会很长，请保持耐心。\n8. 项目上传     颠勺已经为您自动初始化了 git 仓库，并增加了 git submodule，后续项目上传仓库按照 git 使用说明使用即可。\n"},{"id":8,"href":"/dianshao-docs/usermanual/project/","title":"项目","parent":"用户手册","content":"    1. 创建项目 2. 增加元数据层 3. 上传项目 4. 本地项目路径 5. 使用 bitbake 命令行      1. 创建项目       在颠勺中创建一个新项目十分简单，只需输入项目名称和你需要使用的 Yocto 版本号\n  目前颠勺支持从 zeus 到 hardknott 四个 Yocto 版本\n  颠勺默认创建的 Yocto 项目中使用 dianshao distro, 使用 systemd 作为启动方式\n  颠勺默认创建的 Yocto 项目中包含如下元数据层\n  注意: 由于国内网络环境问题，元数据层仓库拉取时间可能会很长，请耐心等待\n2. 增加元数据层       默认创建的项目中只包含基本的元数据层，用户可以根据项目需要在项目创建完成后手动增加元数据层\n  点击项目详情里的 ADD META LAYER 即可手动增加\n  增加时需要填写名称、仓库路径、远程或者本地、子路径\n  其中仓库路径仅在选择远程拉取时需要填写\n  子路径主要是为了适配多个元数据层在一个代码仓库的情况，例如 meta-openembedded\n  颠勺会自动拉取仓库，增加 git submodule, 将元数据层添加至 Yocto 配置文件\n  3. 上传项目       项目默认使用 git 进行项目管理\n  颠勺在创建项目时会默认初始化 git 本地仓库，增加 git submodule, 用户仅需 add, commit, push 即可上传项目至 git 远程仓库中\n  4. 本地项目路径     生成的 yocto 项目还需要后续的开发，例如下一章节说的底层开发，因此用户还需要按照传统 yocto 项目的开发方式进行开发。\n生成的 yocto 项目位于 $DIANSHAO_YOCTO_PROJECT_PATH, 用户可以使用任意 IDE 打开项目，例如 vscode\n5. 使用 bitbake 命令行     颠勺最大程度上还原了 bitbake 命令行显示方式，但对于 Error 的显示仍然不如命令行清晰，因此您可以在编译失败时使用命令行查看详细原因\n您无需搭建 yocto 编译环境，进入 docker-yocto docker container 即可使用 bitbake 命令\ndocker exec -it dianshao-yocto bash cd ../yocto/${project_name} source oe-init-build-env bitbake target "},{"id":9,"href":"/dianshao-docs/yocto/","title":"Yocto 教程","parent":"欢迎使用颠勺","content":""},{"id":10,"href":"/dianshao-docs/usermanual/machine/","title":"底层开发","parent":"用户手册","content":"    1. 说明 2. u-boot 3. kernel 4. 额外驱动 5. rauc 适配开发 6. machine conf 7. distro conf 8. 总结      1. 说明     正如快速开始章节所说，由于嵌入式 Linux 项目会使用各种各样的芯片和外设，无法归纳和总结成一套固定的程序。因此颠勺目前不提供如下 Yocto 开发的支持：\n u-boot 包开发 内核包开发 驱动包开发 rauc 适配开发 machine 配置文件 distro 配置文件  对于开发嵌入式 Linux 项目来说，所有的底层工作 90% 以上是移植。通常来说，开发人员的主要工作是根据需求修改 u-boot 和内核 config 文件并编译，增加额外驱动，修改设备树。 Yocto 提供了丰富的底层软件包，用户一般只需要根据需求做少量的改动即可完成，降低移植难度，后续例程中会简单介绍颠勺项目如何进行底层移植。\n2. u-boot       对于常用芯片，可以使用 openembedded-core/meta/recipes-bsp/u-boot 包，该包使用的是 u-boot 官方仓库。也可以使用芯片厂商提供的元数据层中的 u-boot 包，例如 imx 系列芯片，可以使用 u-boot-imx\n  通常用户只需要修改 config 文件，增加 dts 文件即可，无需过多修改即可完成移植\n  如果需要打补丁也很简单，具体方式请参考 yocto 文档，本文不再赘述\n  3. kernel      同 u-boot 一样，通常只需修改 config 文件，增加 dts 文件即可，无需过多修改即可完成移植  4. 额外驱动      如果你需要增加内核中没有的驱动，Yocto 也提供了方法添加用户驱动，并可使其开机自动加载，具体方法请参考 yocto 文档  5. rauc 适配开发      由于嵌入式 Linux 终端可能使用的存储方法多样，如 nand nor sd emmc 等，且使用的文件系统也不相同，因此需要根据需求增加 rauc bbappend 适配。具体方法请参考 rauc 官方文档。如果你不需要使用 rauc 升级，那可以跳过此步。  6. machine conf       通常，主流芯片厂商和开发板均已提供较为完善的 machine conf, 用户只需根据需求少量修改 machine conf 文件即可\n  用户也可自己开发 machine conf, 具体方式请参考 yocto 官方文档\n  7. distro conf       颠勺会默认创建 distro conf, 使用 systemd 作为启动方式，使用 rauc 进行升级\n  你也可以根据需求在默认配置上增加，也可以自己新建配置文件并使用，具体方法参考 yocto 官方文档\n  8. 总结       总的来说，该部分开发需要开发人员掌握 yocto 开发框架和嵌入式 Linux 底层移植开发知识，因此需要经验丰富的开发人员完成该部分工作。我也尝试过归纳总结成一段程序，但是真的很难实现。\n  由于 yocto 框架的复用性层级之间的解耦做的很好，底层开发者只需关心与硬件平台适配即可，因此一个专职底层开发人员可以配合很多具体项目。例如公司常用芯片一般也就三四种，底层开发人员只需完成针对这几种芯片的底层移植开发，以及根据实际项目需求修改外设相关部分，就可以支撑几十上百个实际项目\n  "},{"id":11,"href":"/dianshao-docs/lora-gateway/package/","title":"软件包","parent":"实例一","content":"    1. 说明 2. EC20  2.1 新建及配置 2.2 添加文件 2.3 安装文件到文件系统 2.4 生成 bbfile 2.5 测试   3. lora-gateway  3.1 创建并配置 3.2 任务 3.3 添加额外定义 3.4 生成 bbfile 并编译   4. packet-forwarder  4.1 创建并配置 4.2 添加本地文件 4.3 增加任务 4.4 生成 bbfile 并编译   5. chirpstack-gateway-bridge  5.1 创建配置项目 5.2 增加本地文件 5.3 增加任务 5.4 生成 bbfile 并编译        1. 说明     lora gateway 在基础文件系统之上，需要添加以下 yocto 包\n ec20: 4G 通信 lora-gateway: sx1301 官方 hal 库 packet-forwarder: semtech 官方 lora 报文转发软件，直接控制 lora 芯片，作为 lora 芯片与上层应用间的桥梁 chirpstack-gateway-bridge: 用于连接 packet-forwarder 与云服务器上的 chirpstack-network-server 服务  2. EC20     我们通过 ppp 拨号使用 4g 数据业务\n2.1 新建及配置     新建 ec20 包如下\n创建完成后进入详情，选择 auto enable systemd, systemd 文件名称填写 ec20.service, 这个是我们即将创建的 systemd service 文件名\n2.2 添加文件     需要添加 ppp_provider, ppp_pap, systemd service 三个文件\n 4g_provider  # example configuration for a dialup connection authenticated with PAP or CHAP # # This is the default configuration used by pon(1) and poff(1). # See the manual page pppd(8) for information on all the options. # MUST CHANGE: replace myusername@realm with the PPP login name given to # your by your provider. # There should be a matching entry with the password in /etc/ppp/pap-secrets # and/or /etc/ppp/chap-secrets. # user \u0026#34;ctnet@mycdma.cn\u0026#34; # password \u0026#34;vnet.mobi\u0026#34; # MUST CHANGE: replace ******** with the phone number of your provider. # The /etc/chatscripts/pap chat script may be modified to change the # modem initialization string. connect \u0026#34;/usr/sbin/chat -s -v -f /etc/chatscripts/4g_pap\u0026#34; # Serial device to which the modem is connected. /dev/ttyUSB2 # Speed of the serial line. 115200 # Assumes that your IP address is allocated dynamically by the ISP. noipdefault # Try to get the name server addresses from the ISP. # usepeerdns # Use this connection as the default route. defaultroute # Makes pppd \u0026#34;dial again\u0026#34; when the connection is lost. persist # Do not ask the remote to authenticate. # noauth debug nocrtscts nodetach ipcp-accept-local ipcp-accept-remote dump ifname \u0026#34;ppp-4g\u0026#34; # lock  4g_pap  ABORT\tBUSY ABORT\tVOICE ABORT\t\u0026#34;NO CARRIER\u0026#34; ABORT\t\u0026#34;NO DIALTONE\u0026#34; ABORT\t\u0026#34;NO DIAL TONE\u0026#34; \u0026#34;\u0026#34; AT\\d \u0026#34;OK\u0026#34;\tAT+CGDCONT=1,\u0026#34;IP\u0026#34;,\u0026#34;3gnet\u0026#34;,,0,0\\d \u0026#34;\u0026#34;\tATD*98*1#\\d CONNECT\t\u0026#34;\u0026#34;  ec20.service  [Unit] Description=EC20 PPP [Service] WorkingDirectory=/usr/sbin ExecStart=/usr/sbin/pppd call 4g_provider SyslogIdentifier=ec20 Restart=always RestartSec=5 [Install] WantedBy=multi-user.target 2.3 安装文件到文件系统     将上一步生成的三个文件安装到文件系统\n 4g_pap: 安装到 /etc/chatscripts 目录下，如下图   4g_provider: 安装到 /etc/ppp/peers 目录下 ec20.service: 安装到 /etc/systemd/system 目录下  2.4 生成 bbfile     点击 generate bbfile, 自动生成 bbfile，内容如下\n# ec20-1.0.0 # Auto Generate by Dianshao FILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/files:\u0026#34; DESCRIPTION = \u0026#34;ec20 module package\u0026#34; LICENSE = \u0026#34;CLOSED\u0026#34; SRC_URI = \u0026#34;\\ file://4g_provider \\ file://4g_pap \\ file://ec20.service \\ \u0026#34; inherit systemd SYSTEMD_AUTO_ENABLE = \u0026#34;enable\u0026#34; SYSTEMD_SERVICE_${PN} = \u0026#34;ec20.service\u0026#34; do_install () { install -d ${D}/etc/systemd/system install -m 0644 ${WORKDIR}/ec20.service ${D}/etc/systemd/system install -d ${D}/etc/chatscripts install -m 0644 ${WORKDIR}/4g_pap ${D}/etc/chatscripts install -d ${D}//etc/ppp/peers install -m 0644 ${WORKDIR}/4g_provider ${D}//etc/ppp/peers } 2.5 测试     点击 bitbake it, 测试生成的包是否能被正确编译\n3. lora-gateway     在 ec20 章节中我们详细介绍了如何新建一个 yocto 包，因此本章节及后续章节只介绍重要内容\n3.1 创建并配置     创建时注意选择项目语言为 C/C++, 下载方式为 git\n配置时有如下要点\n Extra Oemake: 填写 CC=\u0026rsquo;${CC}\u0026rsquo;,AR=\u0026rsquo;${AR}\u0026rsquo;, 使用 yocto 环境变量中的编译器，确保与整个项目保持一致 src url: 从 github 拉取该项目，填写 git://git@github.com/Lora-net/lora_gateway.git;protocol=https;tag=v${PV}; 这是 yocto 要求的写法  3.2 任务     由于该项目为 hal 库，因此只需编译成 .a 文件供其他项目编译使用，无需安装到文件系统中。因此我们只需增加一条编译任务 oe_runmake\n3.3 添加额外定义     编译时无需优化参数，因此添加 INSANE_SKIP_${PN} += \u0026ldquo;ldflags\u0026rdquo;\n3.4 生成 bbfile 并编译     按照 ec20 章节中操作即可\n4. packet-forwarder     4.1 创建并配置     创建时注意选择项目语言为 C/C++, 下载方式为 git\n配置时有如下要点\n Extra Oemake: 填写 CC=\u0026rsquo;${CC}\u0026rsquo;,AR=\u0026rsquo;${AR}\u0026rsquo;, 使用 yocto 环境变量中的编译器，确保与整个项目保持一致 src url: 从 github 拉取该项目，填写 git://git@github.com/Lora-net/packet_forwarder.git;protocol=https;tag=v${PV}; 这是 yocto 要求的写法 Depends: 依赖 lora-gateway, 需要其编译产生的 .a 文件  4.2 添加本地文件      增加 packet-forwarder global_conf.json, 具体请见 semtech 说明 增加 packet-forwarder local_conf.json，具体请见 semtech 说明 增加 Makefile patch, 以使用 lora-gateway 产生的 .a 文件  --- ./Makefile +++ ./Makefile @@ -4,7 +4,7 @@ ### Environment constants -LGW_PATH ?= ../../lora_gateway/libloragw +LGW_PATH ?= ../../../../lora-gateway/5.0.1-r0/git/libloragw ARCH ?= CROSS_COMPILE ?=  增加 systemd service 文件，packet-forwarder.service 增加 packet-forwarder 启动脚本，主要是要增加重启 lora 模组命令  4.3 增加任务       编译任务: oe_runmake\n  创建文件夹 /usr/libexec/lora\n  安装 systemd 文件：安装 packet-forwarder.service 到 /etc/systemd/system\n  安装 lora_pkt_fwd 及配置文件到 /usr/libexec/lora\n  4.4 生成 bbfile 并编译     按照 ec20 章节中操作即可\n5. chirpstack-gateway-bridge     该项目为 golang 项目，打算用本例说明如何创建一个 golang 项目包\n5.1 创建配置项目     创建时注意选择项目语言为 golang, 下载方式为 git\n配置时 golang 相关选项如下\n goproxy: 使用 goproxy.io extra go env: 额外 golang 环境变量设置，通常不用填，除非需要配置私有仓库之类 depends：golang 项目编译依赖 go-native inherit: golang 项目需要集成 goarch, 项目生成时已自动添加，用户检查下是否存在即可  5.2 增加本地文件      systemd service: 和前几章节一样，增加 systemd service 文件 chirpstack-gateway-bridge 配置文件，请参考 chirpstack 官方文档  5.3 增加任务      编译任务：由于该项目中使用 Makefile, 因此使用 oe_runmake 进行编译 安装可执行文件：将可执行文件 chirpstack-gateway-bridge 安装于 /usr/bin/chirpstack-gateway-bridge 安装配置文件：将配置文件 chirpstack-gateway-bridge.toml 安装于 /etc/chirpstack-gateway-bridge 安装 systemd service 文件：将 chirpstack-gateway-bridge.service 安装于 /etc/systemd/system  5.4 生成 bbfile 并编译     按照 ec20 章节中操作即可\n"},{"id":12,"href":"/dianshao-docs/usermanual/package/","title":"软件包","parent":"用户手册","content":"    1. 说明 2. 创建 3. 参数设置 4. 增加本地文件 5. 增加任务 6. 增加额外宏定义 7. 生成 bbfile      1. 说明     颠勺提供 MyPakcage 功能帮助开发者快速的创建 yocto 包，包括以下功能\n 自动生成 yocto bb/bbappend file 生成并添加包所需额外文件，如配置文件、systemd service 文件等 生成并添加软件项目补丁  目前支持 C/C++ golang 两种编程语言软件项目 yocto 包的制作\n2. 创建     点击 New Package 创建包，填写包必要信息\n Version: 请保持和软件版本相同，用于拉取正确版本软件 Type: 是 yocto bb 包还是 bbappend 包 Language: 编程语言是 C/C++ 还是 Golang Download Method: 源码仓库下载方式选择 Initial Method: 软件启动方式选择，目前仅支持 Systemd  3. 参数设置     用户需要填写下列参数，颠勺会根据这些参数生成 bbfile\n GORPOXY: 配置 golang 项目编译时的 go module 代理 Extra Golang Env Variable: 除了 GOROOT GOOS GOARCH GOARM GOCACHE GOPROXY 之外的 GO 环境变量 Extra Oemake: 对应 yocto 变量 $EXTRA_OEMAKE, 详细说明请参考 yocto 文档 Source Directory: 源码目录，例如使用 git 方式拉取，就是 $WORKDIR/git Depends：包依赖，yocto 概念，详细说明请参考 yocto 文档 Inherit：包继承，yocto 概念，详细说明请参考 yocto 文档 Service Auto Enable：systemd 服务自动启动选项 Service File Name: systemd service 文件名称 Src Url: 源码仓库下载地址 Src Revision: 拉取 git 仓库时，如果仓库没有 tag, 则需要填写 commit 版本号 Src Url Md5: 通过 wget 拉取文件时，需要填写文件 md5 校验 Src Url Sha256: 通过 wget 拉取文件时，需要填写文件 sha256 校验  4. 增加本地文件     构建 yocto 包时经常需要增加本地文件到文件系统，例如 systemd service 文件，例如补丁\n create new files: 增加一个新的文件，点开后，输入文件名以及文件内容 create patch: 增加一个源码补丁，点开后，输入补丁名称，源码项目中路径，以及修改前后内容  5. 增加任务     bbfile 中有 config, build, install 三种任务，用户添加后，颠勺会将其加到 bbfile 中\n add original task: 该功能含义为增加一个 bbfile 原始任务，即颠勺会将该行原封不动的写入 bbfile 中。可选 config, build, install 三种任务，可选 prepend, none, append 三种子类型 add install task: bbfile 中有较多将文件安装于文件系统某处的 install 任务，使用该功能可以简化任务填写，只需填写文件名，源路径，安装路径，权限  6. 增加额外宏定义     由于 yocto 功能复杂，上述功能无法 100% 满足其所有场景，因此用户可以通过该功能添加需要的 yocto 宏定义\n7. 生成 bbfile     完成上述添加后，点击 Generate bb/bbappend file 生成 yocto 包，包括 bbfile 以及本地文件\n用户可以点击 bitbake it! 测试添加的 yocto 包是否正确\n"},{"id":13,"href":"/dianshao-docs/lora-gateway/","title":"实例一","parent":"欢迎使用颠勺","content":"本例程将带大家使用颠勺开发一款 LoraWan 网关，帮助大家更快掌握颠勺\n"},{"id":14,"href":"/dianshao-docs/lora-gateway/image/","title":"镜像","parent":"实例一","content":"    1. 说明 2. 创建镜像 3. 镜像制作 4. 文件系统制作 5. 与上菜配合使用 6. 生成镜像、升级包 bbfile 7. 编译镜像 8. 上传升级包      1. 说明     lora gateway 镜像除了基础文件系统之外，主要包括 ec20, packet-forwarder, chirpstack-gateway-bridge 三个软件包\n2. 创建镜像     我们基于 poky-base 制作文件系统，并选择 sd 作为存储方式\n3. 镜像制作     我们使用 freescale 官方提供的 wks 文件，因此不需要自己创建 wks 文件\n4. 文件系统制作     文件系统需要添加 ec20, packet-forwarder, chirpstack-gateway-bridge 三个文件包，同时增加一个 sudo 软件包，增加 admin 用户\n5. 与上菜配合使用     6. 生成镜像、升级包 bbfile     点击 make image file 自动生成镜像 bbfile\n7. 编译镜像     点击 bitbake image!! 开发编译构建镜像\n8. 上传升级包     "},{"id":15,"href":"/dianshao-docs/usermanual/image/","title":"镜像","parent":"用户手册","content":"    1. 说明 2. 创建 3. 镜像制作 4. 文件系统制作 5. 与上菜配合使用 6. 增加额外宏定义 7. 生成镜像、升级包 bbfile 8. 编译镜像 9. 编译并上传升级包      1. 说明     颠勺提供 MyImage 功能帮助开发者快速制作文件系统、镜像以及升级包\n2. 创建     点击 New Image 创建新的镜像，填写必要信息\n Base: 由于文件系统包含太多文件，因此 yocto 提供了两种基础文件系统供我们在其基础上添加自己的文件。其中 minimal 只包含启动所必须的文件，base 则包含了芯片所有外设的固件库 Flash: 选择终端使用的 Flash 类型，目前提供 spi-nor, rawnand, sd 可选  3. 镜像制作      目前 Yocto 只支持 sd 卡的镜像制作，用户通过点击 ADD WKS FILE 创建 Wic File 确定分区，yocto 会自动构建wic 镜像 主流芯片及开发板厂商通常会在其元数据层中提供默认 wic file，因此也可以不填  4. 文件系统制作     文件系统的含义无非就是包含哪些软件及相关文件，而 yocto 包已经将每个软件相关文件编译安装方式完成，因此这里只需填写需要包含哪些 yocto 包，每个包之间用逗号间隔\n5. 与上菜配合使用     传统方式下，开发者每次编译完成后会手动将镜像烧入终端，进行调试，在频繁修改固件调试时不太方便。\n颠勺可以与 上菜配合使用，实现开发阶段固件自动更新，方便开发者频繁修改固件测试\n compitable: rauc 固件适配参数设置，请参考 rauc 官方文档说明 product id: 该终端所属产品在上菜平台上的产品 ID fs type: 升级包文件系统类型，例如 ext4 version: 升级包版本号，在开发阶段，版本号无需正式，用于方便开发者自己区分 file path: 升级包在 build 文件夹下路径，例如 \u0026ldquo;build/tmp-glibc/deploy/images/raspberrypi4\u0026rdquo; file name: 升级包名称，例如 \u0026ldquo;update-bundle-ota-test-image-raspberrypi4.raucb\u0026rdquo; stage: 固件阶段，默认为 dev, 固件阶段定义请参考上菜文档 dishes url: 上菜平台 url  如果您无需集成上菜进行自动更新，此部分可以略过\n6. 增加额外宏定义     由于 yocto 功能复杂，上述功能无法 100% 满足其所有场景，因此用户可以通过该功能添加需要的 yocto 宏定义。这些宏定义会写入生成的镜像 bbfile 中\n7. 生成镜像、升级包 bbfile     点击 make image file 自动生成镜像 bbfile\n8. 编译镜像     点击 bitbake image!! 开发编译构建镜像，由于 yocto 完全从源码开始编译，加上国内网络较慢，编译时间可能会很长，一两天时间也是正常的\n9. 编译并上传升级包     点击 Generate update package 编译生成 rauc 升级包 点击 dishes image 将升级包上传至上菜平台，由其通知终端进行升级\n"},{"id":16,"href":"/dianshao-docs/tags/","title":"Tags","parent":"欢迎使用颠勺","content":""},{"id":17,"href":"/dianshao-docs/quickstart/","title":"入门","parent":"欢迎使用颠勺","content":"本章节中将会用几分钟的时间带您感受颠勺\n"},{"id":18,"href":"/dianshao-docs/roadmap/","title":"教程","parent":"欢迎使用颠勺","content":""},{"id":19,"href":"/dianshao-docs/","title":"欢迎使用颠勺","parent":"","content":"颠勺是一个嵌入式 Linux 项目构建管理工具，它主要基于 Bitbake和 Yocto项目使用。目的是降低 Bitbake 的使用门槛，提高 Yocto 项目的开发体验。\n 使用手册   Github 仓库项目特点   项目管理优雅可靠   一个嵌入式 Linux 终端项目过于零散，由许多小的软件项目组成，如何使用优雅的方式管理项目是一个挑战。颠勺所有上有软件项目仓库集成管理，从源码编译各项目并打包制作镜像文件，避免出现终端项目管理混乱的情况。  标准化的项目开发流程   颠勺致力于提供基础且标准化的嵌入式 Linux 项目开发流程，包括底层软件移植开发流程、应用软件开发规范、项目集成规范等。目标是提高开发效率、提升产品质量、方便后续产品升级维护。  快速上手，简单易用   Bitbake 和 Yocto 是非常棒的项目，但是其学习曲线十分陡峭，对新手不友好。颠勺可以自动创建 BBFILE，具备优秀的 Bitbake UI 界面，可以帮助初学者更快的学会开发 Yocto 项目。   "}]